\chapter{Introduction}

\label{Chapter1}

%\todo{Write this second to last.}

The motivation for thesis was inspired by the creation of a 3D simulator titled BlenderSim. Using Blender\footnote{Blender, released under the GNU General Public License, is a 3D creation suite allowing artists and programmers alike to produce immersive audio/visual works ranging from animation shorts to real-time 3D interactive games. Features include 3D modeling, 3D sculpting, texturing, sound editing, film editing, motion tracking, rigging, rendering, animation, physical simulation, a real-time 3D engine, and extensibility via the integrated Python API \cite{Hess:2007:EBG:1543288}.}, a 3D simulator was constructed for a human and robot multi-agent framework known as HRTeam \footnote{The purpose of HRTeam is to explore human and robot teamwork interactions \cite{hrteam}\cite{sklar-et-al-arms:2011}.}. By using BlenderSim, HRTeam experiments could be conducted in a real-time 3D physics-based virtual environment. The goal of BlenderSim was to provide a robust and high-fidelity simulation such that experimental results produced in simulation would be reproducible in reality.  

The physics engine employed by Blender, called Bullet\footnote{Bullet is the real time physics engine used by Blender. Released under the zlib license, Bullet provides real time continuous collision detection and rigid body dynamics \cite{website:continuousphysics}.}, proved to be troublesome while developing BlenderSim. The simulated robots would ``jitter'' erratically, fall through the floor, fly through the air, and/or fall apart even with no applied forces. Many days, turning into weeks, were lost trying to find the correct physics parameters by hand such that the simulation would produce high-fidelity results. In order to progress on the development of the BlenderSim 3D simulation environment, the idea of using the physics engine to model the motion of the robots was abandoned and a constant velocity motion model was used in its place. 

In the interim, the thesis problem was to tune the Blender physics engine via a genetic algorithm (GA) such that the physics engine would more closely model the motion of a real robot used in HRTeam experiments. This problem was approached in three incremental stages where each subsequent stage built off of the research and development done during the previous stage. Stage one involved the development a GA that tuned the weights of a neural network (NN) where the NN governed the movement of a paddle in a ``Pong''-like game titled SimPL. Using the GA developed in stage one, stage two tuned the Blender physics engine as it iteratively compared the motion of a simulated robot to motion data collected on a real robot. Lastly, with the physics engine tuned in stage two, stage three compared the motion of a simulated robot versus a real robot by simulating a previously conducted HRTeam experiment.           

\section{Genetic Algorithms}

Inspired by the theory of evolution, GAs attempt to solve problems that involve multidimensional state spaces \cite{ColinReeves}\cite{Beasley93anoverview}. GAs overcome problems experienced by other algorithms, such as hillclimbing, random search, or simulated annealing, by using a mixture of exploitation and exploration \cite{Beasley93anoverview}. Running in a loop, a GA generates proposed solutions to a problem, evaluates each proposed solution's value, and then capitalizes on what it learned to produce further potential solutions. Applications of GAs include numerical function optimization, image processing, combinatorial optimization, and civil engineering \cite{Beasley93anoverview}. What problems are appropriate for GAs and why GAs work when they do are highly debated topics with no dominant answers \cite{ColinReeves}. With so many variations and parameters values possible, no two GA implementations are guaranteed to be identical, ``...the number of variations that have been suggested is enormous. Probably everybody's GA is unique!'' \cite{ColinReeves}.

The term \textit{genetic algorithm} has both a strict and broad definition \cite{Whitley94agenetic}. The strict definition of a genetic algorithm is the model formally presented by John Holland in 1975 \cite{ColinReeves}. More generally, the broad definition is, ``any population-based model that uses selection and recombination operators to generate new sample points in a search space''\cite{Whitley94agenetic}. \textit{Genetic algorithm}, as it is used in this text, should be interpreted with the broad definition. Additional terms used require their own distinctions. \textit{Gene} refers to a single encoded value, representative of a dimension inherent to some multidimensional problem. \textit{Genes} are a collection of encoded values that represent a state in some multivariate state space. A \textit{Genome} specifies a data structure that contains genes and other types of data such as the genome's fitness. The \textit{population} of a GA is made up of genomes. The terms \textit{genotype} and \textit{phenotype} are interconnected. A genotype is represented by the genes of a genome. By expressing or rather decoding a genotype, a phenotype is constructed. Specifically for SimPL, the genotype was an encoding of the NN's weights and the phenotype was the paddle's movement, as dictated by the NN. For the software developed in stage two (known as BBAutoTune), the genotype was an encoding of the physics engine's parameters and the phenotype was the simulated robot's collision bounds and motion, as modeled by the physics engine.           

% in this text is used in the \textit{genetic algorithm}, \textit{gene}, \textit{genome}, \textit{genotype}, and \textit{phenotype} used in this thesis should be interpreted using the broad definition.

\section{SimPL}

Instead of diving right into the difficult problem targeted by the thesis, SimPL was an intermediate step to developing a GA capable of tuning a 3D physics engine. The problem for SimPL involved a NN and an on-screen paddle and ball. With the NN controlling the movement of the paddle, the GA developed for SimPL continuously tuned the weights of the NN. With each tuning of the weights, the NN became progressively better at controlling the paddle to hit the ball consistently. This simpler but still related problem provided a tractable context to conduct the needed background research of GAs. With the knowledge gained by solving the problem for SimPL, the thesis project was set up for success.    

\section{BBAutoTune}

The core work of the thesis was BBAutoTune. Using the SimPL GA as a base, the goal of BBAutoTune was to tune the Blender physics engine via a GA such that the physics engine would closely model the motion of a real robot used in HRTeam experiments.  With a few modifications, the SimPL GA was easily converted to handle the thesis problem. After collecting data on the motion of the real robot, BBAutoTune learned the necessary physics parameters needed to make the physics engine closely model the motion of the real robot. The motion of the real robot learned was its forward motion given a forward command.      

\section{BlenderSim}

% BlenderSim was a Blender based, 3D simulator developed for HRTeam during the summer of 2013. Initially, the physics engine in Blender was used to simulate the motion of the robots used in HRTeam experiments. However the physics engine was largely unusable and no amount of parameter tweaking provided consistent and stable results. Thus the physics engine was abandoned as the motion model and a constant velocity model was used in its place. As a proof-of-concept of the thesis, BlenderSim (and specifically the physics engine itself) was revisited using the tuned parameters found by BBAutoTune. By rerunning a previously run HRTeam experiment, the motion of the simulated, physics-based robot was compared with the motion of the real robot.

BlenderSim was a Blender based, 3D simulator developed for HRTeam during the summer of 2013. As a proof of concept of the thesis, BlenderSim (and specifically the physics engine itself) was revisited using the tuned parameters found by BBAutoTune. By rerunning a previously run HRTeam experiment, the motion of the simulated, physics-based robot was compared with the motion of the real robot. 

