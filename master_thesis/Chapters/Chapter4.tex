\chapter{BBAutoTune}

\label{Chapter4}

\section{Overview}

The purpose of BBAutoTune is to find the correct combination of physics parameters such that the motion of the simulated robot is indistinguishable from the real world counterpart. Components of BBAutoTune include a genetic algorithm, database manager, GUI panel, and an external progress monitor which tracks various metrics of the running genetic algorithm.  

\section{Implementation}

Most of the components to BBAutoTune run inside of Blender itself with the exception of the external GA monitor. Blender's API uses the Python programming language and thus BBAutoTune was written entirely in Python. 

\subsection{Surveyor SRV-1 Blackfin 3D Model}

The robot used during experimentation was a 3D model of the Surveyor SRV-1 Blackfin. This model is dimensionally and aesthetically based on the real robot. The extents of the model are $17.64cm\times14.53cm\times14.33cm$ including the braille hat the rests above the body of the robot. The base and the wheels are the only physics based objects on the model with the wheels being connected to the base via a rigid body hinge joint. See Figure \ref{fig:srv1_3d_model}.

\subsection{GUI}

Blender's graphical user interface can be extended via its Python API. BBAutoTune adds a custom panel to Blender that allows the user to specify certain parameters pertaining to the GA and the overall tuning loop. Once the user specifies their preferred parameters, they press start to begin the tuning process. After pressing start, BBAutoTune will continue to run until the GA has reached the max generations specified. See Figure \ref{fig:bbautotune_gui}. 

\begin{figure}[htbp]
\centering
\includegraphics[scale=0.6]{../Figures/Chapter4/bbautotune_gui.png}
\rule{35em}{0.5pt}
\caption[BBAutoTune GUI Panel]{Here you see the BBAutoTune GUI panel added to Blender.}
\label{fig:bbautotune_gui}
\end{figure}

\subsection{Physics Engine API}

Blender exposes the Bullet\footnote{Bullet is the real time physics engine used by Blender. Released under the zlib licence, Bullet provides real time continuous collision detection and rigid body dynamics \cite{website:continuousphysics}.} physics engine API via its own Python API. Most if not all of the parameters to Bullet can be modified via the physics engine API during or before running the Blender game engine. There are 41 different physics engine parameters that can be set via the API.

\subsubsection{Parameter Set and Ranges}

See Table \ref{tab:physics_params_ranges}.

\begin{table}[htbp]
\centering
\footnotesize
\bgroup
\def\arraystretch{1.1}
\begin{tabular}{ | >{\centering\arraybackslash}m{4cm} | >{\centering\arraybackslash}m{4cm} | >{\centering\arraybackslash}m{4cm} | }
\hline
\rowcolor{gray}
Parameter        & Range                                       & Default Value \\ \hline
Gravity          & [0.0$\frac{m}{s^2}$,10000.0$\frac{m}{s^2}$] & 9.8$\frac{m}{s^2}$ \\ \hline
Mass             & [0.0,10000.0]                               & 1.0\\ \hline
Force            & [-inf,inf]                                  & 0.0 \\ \hline
Torque           & [-inf,inf]                                  & 0.0 \\ \hline
Linear Velocity  & [-inf,inf]                                  & 0.0 \\ \hline
Angular Velocity & [-inf,inf]                                  & 0.0 \\ \hline
Apply Force Locally & [False,True] & True \\ \hline
Apply Torque Locally & [False,True] & True \\ \hline
Apply Linear Velocity Locally & [False,True] & True \\ \hline
Apply Angular Velocity Locally & [False,True] & True \\ \hline
Use Material Physics & [False,True] & True \\ \hline
Material Friction & [0.0,100.0] & 0.5 \\ \hline
Material Elasticity & [0.0,1.0] & 0.0 \\ \hline
Material Force & [0.0,1.0] & 0.0 \\ \hline
Material Damping & [0.0,1.0] & 0.0 \\ \hline
Material Distance & [0.0,20.0] & 0.0 \\ \hline
Material Align to Normal & [False,True] & False \\ \hline
Actor & [False,True] & True \\ \hline
Ghost & [False,True] & False \\ \hline
Physics Type & [NO\_COLLISION, STATIC, DYNAMIC, RIGID\_BODY, SOFT\_BODY, OCCLUDE, SENSOR, NAVMESH, CHARACTER] & STATIC \\ \hline
Use Material Force Field & [False,True] & False \\ \hline
Rotate From Normal & [False,True] & False \\ \hline
No Sleeping & [False,True] & False \\ \hline
From Factor & [0.0,1.0] & 0.4 \\ \hline
Use Anisotropic Friction & [False,True] & False \\ \hline
Anisotropic Friction XYZ & [0.0,1.0] & 1.0 \\ \hline
Velocity Min/Max & [0.0,1000.0] & 0.0 \\ \hline
Lock Translation XYZ  & [False,True] & False \\ \hline
Lock Rotation XYZ & [False,True] & False \\ \hline
Damping Translation & [0.0,1.0] & 0.025 \\ \hline
Damping Rotation & [0.0,1.0] & 0.159 \\ \hline
Use Collision Bounds & [False,True] & False \\ \hline
Collision Radius & [0.01m,inf] & 1m \\ \hline
Collision Bound Type & [BOX, SPHERE, CYLINDER, CONE, CONVEX\_HULL, TRIANGLE\_MESH, CAPSULE] & BOX \\ \hline
Collision Margin & [0.0m,1.0m] & 6cm \\ \hline
Max Physics Steps & [1,5] & 5 \\ \hline
Physics Sub-steps & [1,50] & 1 \\ \hline
FPS & [1,10000] & 60 \\ \hline
Linear Deactivation Threshold & [0.001,10000.0] & 0.8 \\ \hline
Angular Deactivation Threshold & [0.001,10000.0] & 1.0 \\ \hline
Deactivation Time & [0.0s,60.0s] & 2.0s \\ \hline
\end{tabular}
\egroup
\caption[Blender Physics Parameters and Ranges]{Here you see the various physics parameters, their ranges, and their default values. Note that inf=340,282,346,638,528,859,811,704,183,484,516,925,440.0 in Blender.}
\label{tab:physics_params_ranges}
\end{table}

\subsection{Database Manager}

Running within Blender, the database manager opens a connection to a local MySQL database. For each evaluated genetic algorithm generation, the database manager stores the generation number, the highest fitness, the average fitness, the lowest fitness, the crossover probability, and the mutation probability in the database. 

\subsection{Robot Monitor}

Running within the Blender game engine, the robot monitor records the position and rotation state of the simulated robot's base throughout the duration of running the game engine. At the very start of the game engine, the robot monitor records the position and rotation state $S$ of the robot's base with a time stamp $T$. After one second has passed, the robot monitor records the position and rotation state $S'$ of the robot's base with a time stamp $T'$. At this point, if the robot's base has come to a rest, the robot monitor exits the game engine. Otherwise, if the robot's base is still moving, the robot monitor will update $S'$ and $T'$ every half second for the rest of the evaluation period. After 16 seconds have elapsed, the robot monitor exits the game engine regardless of whether or not the robot's base is still moving. Every time the robot monitor records $S'$ and $T'$, it writes $S$, $S'$, $T$, and $T'$ to a file that will be later read by the fitness function.  

\subsection{Progress Monitor}

The progress monitor is an external and self-contained Python HTTP-CGI server that listens on port 8000. By visiting  \texttt{http://localhost:8000/index.py}, a user can track the GA's progress concerning the highest fitness, average fitness, lowest fitness, crossover probability, and the mutation probability. See Figure \ref{fig:ga_monitor}. Once the user presses start on the GUI panel, BBAutoTune starts the server as an external process with the option of opening a browser to the progress page. Once every minute, the progress monitor retrieves the most current GA run information from the local MySQL database which was populated by the database manager.

\begin{figure}[htbp]
\centering
\includegraphics[scale=0.6]{../Figures/Chapter4/ga_monitor.png}
\rule{35em}{0.5pt}
\caption[GA Progress Monitor]{Here you see external GA progress monitor.}
\label{fig:ga_monitor}
\end{figure}

\subsection{Genetic Algorithm}

The genetic algorithm for BBAutoTune was borrowed from the SimPL project and ported to Python with some aspects of the GA being altered to suit the needs of BBAutoTune. Since lower values of fitness are considered higher than those of higher values of fitness, the population sorting function needed to be altered. Other portions altered were the selection operator, the population metrics calculator, and the self-adaptation algorithm.  

\subsubsection{Encoding Scheme}

The physics parameters selected for tuning were a mixed set of floats, integers, string arrays, and boolean values. To ease the process of crossover and mutation, all genome genes were homogenized to a normalized range of $[0.0,1.0]$. Let any given genome's gene value be $g_i$ and any given physics parameter be $p_i$. For a float type with a maximum range value $r_{max}$ and minimum range value $r_{min}$, the mapping function was $p_i=(g_i*(r_{max}-r_{min}))+r_{min}$. For an integer type with a maximum range value $r_{max}$ and a minimum range value $r_{min}$, the mapping function was $p_i=\lfloor(g_i*(r_{max}-r_{min}))+r_{min}\rfloor$. For an array $A$ of strings type with size $n$, the mapping function was $p_i=A[\lfloor g_i*(n-1)\rfloor]$. Finally for a boolean type, the mapping function was 

\[ p_i = \left\{
\begin{array}{l l}
True & \quad \text{if $g_i\geq 0.5$,}\\
False & \quad \text{if $g_i < 0.5$.}
\end{array} 
\right.\]

\subsubsection{Operators}

The operators used include selection, elitism, crossover, and mutation. All of these operators work together to generate a new population once the current population has been fully evaluated by the fitness function.

The selection operator includes two variants: tournament selection and rank fitness selection. The user can indicate on the GUI panel if rank fitness selection is to be used---otherwise tournament selection will be used. Tournament selection works by gathering a sub-portion of the total population where the fittest genome among the sub-portion is selected thereby winning the tournament \cite{Miller95geneticalgorithms}. While gathering the sub-portion, all genomes in the population have a uniform probability of being included in the tournament regardless of their respective fitness values. There is the possibility that the same genome may be included in the tournament more than once. For crossover, two tournaments of size three are run thereby giving two genomes to be crossed. For mutation, one tournament of size two is run thereby giving one genome to be mutated. Rank fitness selection works by first sorting the population in non-increasing order according to fitness and then selects a genome at random where the probability of a genome being selected is proportional to its rank fitness. With the population in sorted order, the first genome is given a rank fitness of 1, the second genome is given a rank fitness of 2, ..., and the last genome is given a rank fitness of $n$ which is the population size. The rank fitness prefix-sum for each genome is calculated in an array such that the first index value in the prefix-sum array is $1$ while the last index value in the prefix-sum array is $\frac{n(n-1)}{2}$. A uniform random number is selected in the range $\left[0,\frac{n(n-1)}{2}\right]$. The genome selected $G$ is the one in which the random number is greater than the previous prefix-sum for genome $G_{i-1}$ and less than or equal to the prefix-sum for $G_i$. Genomes with a higher fitness will have a higher rank fitness and thus will have a higher probability of being selected for either crossover or mutation. See Figure \ref{fig:rank_fitness_selection}. 

\renewcommand{\baselinestretch}{1.0}

\begin{figure}[htbp]
\begin{center}
\begin{varwidth}{\textwidth}
{\tt
BEGIN \\
\tab Population $P$ with size $n$ has been evaluated \\
\tab Sort $P$ in non-increasing order \\
\tab For i=1 to $n$ do \\
\tab \tab $P[i-1].rankFitness = i$ \\
\tab End for \\
\tab For i=0 to $n-1$ do \\
\tab \tab $P[i].prefixSum = \sum\limits_{k=0}^i(P[k].rankFitness)$ \\
\tab End for \\
\tab Select a random number $r=unif\left(0,\frac{n(n-1)}{2}\right)$ \\
\tab Genome selected $G$ \\
\tab For i=0 to $n-1$ do \\
\tab \tab If $P[i].prefixSum \geq r $ then \\
\tab \tab \tab $G=P[i]$ \\
\tab \tab \tab Break \\
\tab \tab End if \\
\tab End for \\
\tab Return $G$ \\
END \\
}
\end{varwidth}
\end{center}
\centering
\rule{35em}{0.5pt}
\caption[Rank Fitness Selection Algorithm]{Here you see the rank fitness selection algorithm.}
\label{fig:rank_fitness_selection}
\end{figure}

\subsubsection{Fitness Function}

\todo{This section only reflects the data recorded using the old move() function. Change to reflect data collected using the new motion() function.}

To construct the fitness function, real robot motion data was collected which included 1040 sample points. X-translation, y-translation, and z-rotation were recorded for the real robot. With a camera overhead, the real robot was place in the arena and was repeatedly commanded to go forward (relative from its current position and orientation) 25 centimeters. Care was taken to avoid having the robot collide with the arena walls. Once the robot consecutively moved forward three times, the robot rotated in place by 135 degrees and was not recorded during this period of rotation.  

Using the camera, the robot's position and orientation before and after performing the forward command was recorded for each forward command issued. The robot's position and orientation was not reset each time the robot performed a forward command. Instead, the robot was allowed to continue forward from its current position and orientation as it traveled around the arena. Thus each recorded pair of initial and final states were translated and rotated to be in the same reference frame such that the robot was always at the arena origin facing down the positive x-axis before performing the forward command. See Figure \ref{fig:real_robot_raw_trans_rot} and \ref{fig:real_robot_forward_motion}. Note that from the robot's perspective, it is always facing down its local positive x-axis no matter its position or orientation as seen from some other reference point.

\begin{figure}[htbp]
\centering
\includegraphics[scale=0.6]{../Figures/Chapter4/real_robot_raw_trans_rot.png}
\rule{35em}{0.5pt}
\caption[Real Robot Forward Motion Data Translated and Rotated Example]{Here you see a specific instance of how the raw real robot forward motion data was translated and rotated such that each pair of initial and final states have the same reference frame. The red arrows, dot, and line represent the raw initial and final state of the robot recorded from the overhead camera before and after it performed the forward command. The blue arrows, dot, and line represent the initial and final state translated to the origin. The green arrows, dot, and line represent the initial and final state rotated by the amount needed to align the initial orientation with the positive x-axis. For each colored group, the dot and arrow pair represent the position and orientation of the robot after having performed the forward command while the arrow without a dot represents the position and orientation state of the robot before it performed the forward command.}
\label{fig:real_robot_raw_trans_rot}
\end{figure}

\begin{figure}[htbp]
\centering
\includegraphics[scale=0.6]{../Figures/Chapter4/real_robot_forward_motion.png}
\rule{35em}{0.5pt}
\caption[Real Robot Forward Motion]{Here you see the collected real robot forward motion plotted from the same reference point. The green dots and arrows indicate the starting position and orientation of the real robot before the forward command was performed. The red dots and arrows indicate the ending position and orientation of the real robot after the forward command was performed. The dots represent position and the arrows represent orientation. The broken blue lines connect the initial states to their corresponding finals states.}
\label{fig:real_robot_forward_motion}
\end{figure}

Analyzing the distribution of x-translation, y-translation, and z-rotation separately, all are unimodal and nearly symmetric with only a slight skew from their respective means. See Table \ref{tab:real_robot_motion_dist} and Figure \ref{fig:real_robot_forward_dist}. When viewing the change in dimensions together, a large mass is centered around the point: 23.8644631679cm, 0.338269853117cm, and -0.00417473025048rad. See Figure \ref{fig:real_robot_3d_scatter}. Based on the variance-covariance matrix, all three dimensions vary together and are not independent from one another \todo{Citation needed?}. 

\begin{table}[htbp]
\centering
\footnotesize
\bgroup
\def\arraystretch{1.1}
\begin{tabular}{ | >{\centering\arraybackslash}m{3cm} | >{\centering\arraybackslash}m{3cm} | >{\centering\arraybackslash}m{3cm} | >{\centering\arraybackslash}m{3cm} | }
%\hline
%\rowcolor{gray}
\cline{2-4}
\multicolumn{1}{c|}{}                  & \cellcolor{gray} X-translation & \cellcolor{gray} Y-translation & \cellcolor{gray} Z-rotation \\ \hline
\cellcolor{gray} Max                   & 46.5183415482cm        & 19.7486813209cm       & 6.23776rad           \\ \hline
\cellcolor{gray} Min                   & 0.0cm                  & -19.4028539247cm      & -1.148163rad         \\ \hline
\cellcolor{gray} Mean/Centroid         & 23.8644631679cm        & 0.338269853117cm      & -0.00417473025048rad \\ \hline
\cellcolor{gray} Mode                  & 25.0cm                 & -1.0cm                & 0.0rad               \\ \hline
\cellcolor{gray} Variance              & 10.3960320996          & 9.46441502772         & 0.152467827567       \\ \hline
\cellcolor{gray} Standard Deviation    & 3.22428784378          & 3.07642894079         & 0.390471289043       \\ \hline
\cellcolor{gray} Covariance with X-translation  & 10.4060572             & 2.3348963             & 0.0685591            \\ \hline
\cellcolor{gray} Covariance with Y-translation  & 2.3348963              & 9.47354175            & 0.08654865           \\ \hline
\cellcolor{gray} Covariance with Z-rotation     & 0.0685591              & 0.08654865            & 0.15261486           \\ \hline
\end{tabular}
\egroup
\caption[Real Robot Forward Motion Distribution Metrics]{Here you see the distribution metrics for surge, sway, and yaw.}
\label{tab:real_robot_motion_dist}
\end{table}

% Number of sample points:  1040
% X' max/min:  46.5183415482 0.0
% X' mode:  (array([ 25.]), array([ 8.]))
% X' mean:  23.8644631679
% X' variance:  10.3960320996
% X' standard deviation:  3.22428784378
% Y' max/min:  19.7486813209 -19.4028539247
% Y' mode:  (array([-1.]), array([ 8.]))
% Y' mean:  0.338269853117
% Y' variance:  9.46441502772
% Y' standard deviation:  3.07642894079
% Theta' max/min:  6.23776 -1.148163
% Theta' mode:  (array([ 0.]), array([ 234.]))
% Theta' mean:  -0.00417473025048
% Theta' variance:  0.152467827567
% Theta' standard deviation:  0.390471289043
% X' normal test p-value:  2.45603600615e-124 Not Normal
% Y' normal test p-value:  1.60589004385e-121 Not Normal
% T' normal test p-value:  0.0 Not Normal
% Covariance matrix: 
% [[ 10.4060572    2.3348963    0.0685591 ]
%  [  2.3348963    9.47354175   0.08654865]
%  [  0.0685591    0.08654865   0.15261486]]
% X', Y', T' Median:  24.0201969119 ,  0.0475373929135 ,  -0.0145985
% X'Y'T' Centroid:  23.8644631679 ,  0.338269853117 ,  -0.00417473025048
% X'Y'T' Geometric Median:  23.9754618867 ,  0.0401244563225 ,  -0.0124671288475

\begin{figure}[htbp]
\centering
\includegraphics[scale=0.6]{../Figures/Chapter4/real_robot_forward_dist.png}
\rule{35em}{0.5pt}
\caption[Real Robot Forward Motion Distributions]{Here you see the distribution of x-translation, y-translation, and z-rotation dimensions recorded for the real robot forward motion. The broken black bar represents the mode, the green broken bar represents the mean, the cyan broken bars represent one standard deviation from the mean, and the red broken curve represents the best fit normal curve.}
\label{fig:real_robot_forward_dist}
\end{figure}

\begin{figure}[htbp]
\centering
\includegraphics[scale=0.5]{../Figures/Chapter4/real_robot_3d_scatter.png}
\rule{35em}{0.5pt}
\caption[Real Robot Forward Motion 3D Scatter Plot]{Here you see a 3D scatter plot of the x-translation, y-translation, and z-rotation values for the real robot after it performed the forward command. Positive values of x-translation, y-translation, and z-rotation contribute a portion of red, green, and blue respectively to each scatter plot. The star located at the center of the large mass of points is the centroid.}
\label{fig:real_robot_3d_scatter}
\end{figure}

With the real robot motion data collected and analyzed, a metric was needed for the fitness function. This metric would need to indicate how different or dissimilar the movement of the simulated robot was from the real robot while running the GA. The intuition was that as the simulated robot motion observed moved closer to the centroid of the real robot motion, the simulated motion would become increasingly indistinguishable from the real motion. Various distance functions were looked at and the Mahalanobis distance was chosen as the basis for the fitness function. The Mahalanobis distance is the generalized form of the Euclidean distance such that the Mahalanobis distance accounts for the correlation in the data set since it is computed using the inverse of the variance-covariance matrix \cite{mahalanobis_distance}. For uncorrelated data, the Mahalanobis distance reduces to the Euclidean distance \cite{what_is_mahalanobis_distance}.

Inefficiencies with the overhead camera and the timing at which the position and orientation state of the real robot was captured could have potentially skewed the real robot motion model with outliers ultimately resulting in a skewed multivariate mean location and a skewed inverse variance-covariance matrix making the Mahalanobis distance skewed. To account for the potential outliers in the real motion data set, a robust mean location and a robust variance-covariance matrix was computed from the data set using the Fast-MCD algorithm implemented in the Scikit-learn Python module \cite{Rousseeuw:1999:FAM:331435.331458}\cite{scikit-learn}. The classical mean location was 23.8644632cm, 0.338269853cm, and -0.00417473025rad for x-translation, y-translation, and z-rotation respectively while the robust mean location was 23.9934044cm, 0.0351240536cm, and -0.0189964938rad for x-translation, y-translation, and z-rotation respectively. The left matrix below was the classical variance-covariance matrix while on the right was the robust variance-covariance matrix returned by the Fast-MCD algorithm.
\vspace{-1mm}
\[ \left( \begin{array}{ccc}
10.3960321 &  2.33264688 & 0.06849305 \\
2.33264688 &  9.46441503 & 0.08646527 \\
0.06849305 &  0.08646527 & 0.15246783 \\
\end{array} \right)
%
\left( \begin{array}{ccc}
1.46298445 & 0.13924542 & 0.00223493 \\
0.13924542 & 1.64197605 & 0.0168499  \\
0.00223493 & 0.0168499  & 0.00173777 \\
\end{array} \right)
\]

\noindent
The resulting samples weighted higher than others by the Fast-MCD algorithm are shown in Figure \ref{fig:robust_support_samples}. These samples where used to calculate the robust mean and the robust variance-covariance matrix returned by the algorithm. By substituting the robust mean and the inverse of the robust variance-covariance matrix into the Mahalanobis distance calculation, the robust distance $RD$ for any sample point can be computed \cite{WICS:WICS61}. Comparisons between the Mahalanobis distance and the robust distance for each of the 1040 real robot motion data points are shown in Figure \ref{fig:real_robot_md_vs_rd}. As the data points travel away from the centroid, the robust distance increases more rapidly than the Mahalanobis distance.  

% Classical Mean (Location):  [  2.38644632e+01   3.38269853e-01  -4.17473025e-03]
% Robust Mean (Location):  [  2.39934044e+01   3.51240536e-02  -1.89964938e-02]
% Classical Covariance Matrix: 
% [[ 10.3960321    2.33264688   0.06849305]
%  [  2.33264688   9.46441503   0.08646527]
%  [  0.06849305   0.08646527   0.15246783]]
% Robust Covariance Matrix: 
% [[ 1.46298445  0.13924542  0.00223493]
%  [ 0.13924542  1.64197605  0.0168499 ]
%  [ 0.00223493  0.0168499   0.00173777]]   

\begin{figure}[htbp]
\centering
\includegraphics[scale=0.5]{../Figures/Chapter4/real_robot_robust_samples.png}
\rule{35em}{0.5pt}
\caption[Real Robot Forward Motion Fast-MCD Support Samples]{Here you see a 3D scatter plot of the support samples in blue used to calculate the robust mean location and the robust variance-covariance matrix as returned by the Fast-MCD algorithm.}
\label{fig:robust_support_samples}
\end{figure}

\begin{figure}[htbp]
\centering
\includegraphics[scale=0.5]{../Figures/Chapter4/real_robot_md_vs_rd.png}
\rule{35em}{0.5pt}
\caption[Real Robot Forward Motion MD versus RD]{Here you see a scatter plot comparing the Mahalanobis distance versus the robust distance for each data point collected of the real robot motion.}
\label{fig:real_robot_md_vs_rd}
\end{figure}

Only three out of the total six degrees of freedom were recorded for the real robot. However, in Blender there were an additional three degrees (pitch, roll, and heave) to contend with.  Thus, the simulated-robot base's x-rotation, y-rotation, and z-translation were constrained. Additionally, all wheels had their z-translation constrained. As an added precaution, penalties where added onto the robust distance by the absolute amount the simulated robot's base violated x-rotation, y-rotation, and/or z-translation. Additionally, a time penalty was added onto the robust distance by the amount of time in seconds the simulated robot took to evaluate greater than one second with a max penalty of 15 seconds since any given evaluation period only lasted a total of 16 seconds.

Once the simulated robot was run through the game engine evaluation period (using the physics parameter settings decoded from the currently being evaluated genome $G_i$'s genes), 14 pieces of data was collected by the robot monitor for use in the fitness function. Let $S=[x_t,y_t,z_t,x_r,y_r,z_r,t]$ be the starting state of the simulated robot at the beginning of the evaluation period at time $S[6]=t$ where the subscript $_t$ refers to translation and the subscript $_r$ refers to rotation. Let $S'=[x_t,y_t,z_t,x_r,y_r,z_r,t]$ be the ending state of the simulated robot at the end of the evaluation period at time $S'[6]=t$. Also, let $RD(x-translation,y-translation,z-rotation)$ be the robust distance. The fitness function and thus the fitness of $G_i$ was defined as $Fitness(S,S')=RD(S'[0]-S[0],S'[1]-S[1],S'[5]-S[5])+|S'[4]-S[4]|+|S'[3]-S[3]|+|S'[2]-S[2]|+((S'[6]-S[6])-1)=G_i$'s fitness. The range of this function is $[0,\infty)$. Since the goal of this thesis was to have the simulated robot move as the real robot, the desired output of this function was $0.0$ implying that three objectives were met:
\begin{itemize}
 \item The simulated robot's x-translation, y-translation, and z-rotation after moving was 23.9934044cm, 0.0351240536cm, and -0.0189964938rad respectively.
 \item The simulated robot stopped moving after one second.
 \item The simulated robot did not fall through the floor, flip over, roll over, and/or launch upward.
\end{itemize}
Thus the goal of the GA was to minimize this function whereby lower output values were a higher fitness than higher output values.

\subsubsection{Evaluation Setup}

For each evaluation period (the running of the game engine), the 3D robot model's local coordinate system was axis aligned with the world coordinate system, the robot was faced forward looking down the positive x-axis, and its local origin was placed at the world origin. See Figure \ref{fig:simu_robot_aligned}. Before each evaluation period, the physics engine parameters were set to the values decoded from the genes of the currently being evaluated genome. All evaluation periods lasted no more than 16 seconds. If the robot stopped moving before 16 seconds, then the evaluation period ended immediately. The only applied force to the robot was the wheel torque where each wheel received the same amount of applied torque for the same duration. The duration of applied torque was roughly 16 milliseconds after which no further force was applied to the robot.

\begin{figure}[htbp]
\centering
\includegraphics[scale=0.5]{../Figures/Chapter4/simu_robot_aligned.png}
\rule{35em}{0.5pt}
\caption[Simulated Robot Axis Aligned]{Here you see the simulated robot's local coordinate system axis aligned with the world coordinate system.}
\label{fig:simu_robot_aligned}
\end{figure}

\section{Platform}

For all experiments, BBAutoTune was run on a 64bit Linux operating system with 32GB of RAM and an Intel Core i7-4770K four core processor running at 3.9GHz.

\section{Experimental Designs}

Stub.

\subsection[Experiment One]{Experiment one: physics engine parameter influence.}

The potential Blender physics engine parameter candidates---to be tuned by the GA---were analyzed for their influence over the physics simulation. To accomplish this goal, a racquetball like environment was constructed in Blender which consisted of a ball, an enclosed arena, and an automated racket controlled via a Python script. See Figure \ref{fig:racquetball}. Note that the ball was allowed to travel in all three dimensions and was completely physics based.

\begin{figure}[htbp]
\centering
\includegraphics[scale=0.4]{../Figures/Chapter4/racquetball.png}
\rule{35em}{0.5pt}
\caption[Physics Engine Parameter Influence Racquetball Environment]{Here you see the racquetball environment used to test the physics engine parameter candidates' influence over the physics simulation.}
\label{fig:racquetball}
\end{figure}

44 candidate parameters were selected for testing in the racquetball environment. All parameters tested were only associated with the ball. Before all of these parameters were tested for their influence, \textit{nice} values were selected for each such that the ball's behavior was visually normal. A standard was established where the ball was allowed to run for five seconds (with all parameters being set to their nice values) during which its location was recorded at roughly 60 times per second. With the standard established---with which all other runs would be compared to---a parameter was selected (from the candidate pool), its value was tweaked, the ball was run for five seconds with its location being recorded at roughly 60 times per second, and after the run was over, the tweaked parameter's value was set back to its nice value. This sequence was repeated for all 44 candidate parameters.

\subsection[Experiment Two]{Experiment two: tournament selection with self-adaptation.}

Very early runs of BBAutoTune attempted to tune physics parameters: gravity, sub-steps, FPS, use material physics, material friction, material elasticity, mass, form factor, velocity maximum, damping translation, damping rotation, use collision bounds, collision bound type, and torque where the search space for each parameter was its entire valid range. This proved to be problematic since some of the valid ranges are quite large especially torque with a max upper bound of $~3.40\times10^{38}$. While running the game engine, if the genome's genes decoded to relatively high physics engine parameter values, world coordinates would return the Python values ``NaN'' or ``inf''.

To rectify this issue, the set of physics parameters selected for tuning was pruned and for the parameters left, their ranges were shortened to reasonable upper and lower bounds found manually. The resulting set of tunable physics parameters and their ranges for experiment two were: gravity [0.0,15.0], sub-steps [1,5], FPS [30,10000], material friction [0.0,100.0], material elasticity [0.0,1.0], mass [0.010,15.0], velocity maximum [0.0,1000.0], damping translation [0.0,1.0], damping rotation [0.0,1.0], collision bound type [TRIANGLE\_MESH,CONVEX\_HULL,CYLINDER,SPHERE], and torque [0.0,100.0]. Use material physics and use collision bounds were set to true and held constant. Form factor was set to 1.0 and was held constant. 

The GA was run for 500 generations with tournament selection, elitism set to 2, crossover and mutation performed separately, and the crossover and mutation probabilities were self-adapted over time.

\section{Experimental Results}

Stub.

\subsection[Experiment One]{Experiment one: physics engine parameter influence.}

To compare the recorded tweaked-parameter ball paths with the recorded standard, four methods were utilized to give an indication as to how much influence any one candidate parameter had over the simulation. The first method was visual inspection. All 44 tweaked-parameter ball paths were plotted against the standard. See Figure \ref{fig:matphysplot} and Figure \ref{fig:logicstepsplot}. The second method was an in-house algorithm, titled the \textit{Lettier distance}, which gives the maximum euclidean distance between two discrete curves $P$ and $Q$. Informally, imagine holding a rubber band in your hands where the left hand affixes the left end of the rubber band to the first point in $P$ and the right hand affixes the right end of the rubber band to the first point in $Q$. During each iteration, you advance the left end of the rubber band to the next point in $P$ and you advance the right end of the rubber band to the next point in $Q$. If the distance grows between point $p_i\in P$ and point $q_j \in Q$, the rubber band stretches but never shrinks. If $|P|<|Q|$ then you hold the left end of the rubber band to the last point in $P$ and continue advancing to the last point in $Q$ and vice versa. Once you reach the last point in $P$ and the last point in $Q$, the resulting length of the rubber band is the max euclidean distance between $P$ and $Q$. See Figure \ref{lettierdistance}. The third method was the Fréchet distance and the fourth method was the Hausdorff distance \cite{frechet} \cite{hausdorff}.

\begin{figure}[htbp]
\centering
\includegraphics[scale=0.35]{../Figures/Chapter4/material_physics_ball_plot.png}
\rule{35em}{0.5pt}
\caption[Physics Engine Racquetball Path Dissimilarity]{Here you see the dissimilarity of the ball paths between the tweaked, material-physics elasticity parameter and the standard (where no parameters were tweaked).}
\label{fig:matphysplot}
\end{figure}

\begin{figure}[htbp]
\centering
\includegraphics[scale=0.35]{../Figures/Chapter4/logic_steps_ball_plot.png}
\rule{35em}{0.5pt}
\caption[Physics Engine Racquetball Path Similarity]{Here you see the similarity of the ball paths between the tweaked, logic-steps max parameter and the standard (where no parameters were tweaked).}
\label{fig:logicstepsplot}
\end{figure}

\begin{figure}[htbp]
\begin{center}
\begin{varwidth}{\textwidth}
{\tt
BEGIN \\
\tab $P = \langle p_1, p_2,...,p_n\rangle$ \\
\tab $Q = \langle q_1, q_2,...,q_m\rangle$ \\
\tab $max = 0.0$ \\
\tab For all $p_i\in P$ and $q_j \in Q$ do \\
\tab \tab $d = ||p_i-q_j||$ \\
\tab \tab If $max$ $<$ $d$ then \\
\tab \tab \tab $max=d$ \\
\tab \tab End if \\
\tab End for \\
\tab Return $max$ \\
END \\
}
\end{varwidth}
\end{center}
\centering
% \begin{equation*}
% \begin{align}
% Algorithm: & \\
% & P = \langle p_1, p_2,...,p_n\rangle \\
% & Q = \langle q_1, q_2,...,q_m\rangle \\
% & max = 0.0 \\
% & For \ all \ p_i\in P \ and \ q_j \in Q \ do: \\
% & \quad d = ||p_i-q_j|| \\
% & \quad If \ max < d \ then: \\
% & \qquad max \leftarrow d \\
% & return \ max \\
% \end{align}
% \end{equation*}
\rule{35em}{0.5pt}
\caption[Lettier Distance Algorithm]{Here you see the Lettier distance algorithm.}
\label{lettierdistance}
\end{figure}

20 parameters out of the initial 44 showed no significant influence over the 3D physics simulation in Blender. Thus, the resulting 24 parameters which did have a significant influence were targeted for tuning by the genetic algorithm. See Table \ref{tab:distances}.

\begin{table}[htbp]
\centering
\footnotesize
\def\arraystretch{1.1}
\begin{tabular}{ | l || l | l | l | }
\hline
\rowcolor{gray}
Tweaked Parameter: Value & Lettier Distance & Fréchet Distance & Hausdorff Distance \\ \hline
Gravity: $1.0\frac{m}{s^2}$ & 12.7741189989 & 20.948159542 & 9.86343687719 \\ \hline
\rowcolor{cyan}
Physics Steps Max: 1 & 0.329232644023 & 0.329232644023 & 0.329232644023 \\ \hline
Physics Sub-steps: 50 & 19.3073641073 & 17.0708640308 & 11.3180046289 \\ \hline
Physics FPS: 1 & 218.037284056 & 211.287842927 & 205.848670021 \\ \hline
\rowcolor{cyan}
Logic Steps Max: 1 & 0.329232644023 & 0.329232644023 & 0.329232644023 \\ \hline
\rowcolor{cyan}
Physics Deactivation Linear Threshold: 10000.0 & 0.329232644023 & 0.329232644023 & 0.329232644023 \\ \hline
\rowcolor{cyan}
Physics Deactivation Angular Threshold: 10000.0 & 0.329232644023 & 0.329232644023 & 0.329232644023 \\ \hline
\rowcolor{cyan}
Physics Deactivation Time: 0.0 & 0.329232644023 & 0.329232644023 & 0.329232644023 \\ \hline
\rowcolor{cyan}
Occlusion Culling: False & 0.329232644023 & 0.329232644023 & 0.329232644023 \\ \hline
\rowcolor{cyan}
Occlusion Culling Resolution: 1024 & 0.329232644023  & 0.329232644023  & 0.329232644023 \\ \hline
Material Physics: False & 18.0830473811 & 18.0830473811  & 18.0830473811 \\ \hline
Material Physics Friction: 100.00 & 4.93924881608  & 4.94095279557  & 3.8109066203 \\ \hline
Material Physics Elasticity: 0.0 & 17.3874844829  & 17.0233755244  & 11.3180046289 \\ \hline
\rowcolor{cyan}
Force Field Force: 1.00 & 0.329232644023  & 0.329232644023  & 0.329232644023 \\ \hline
\rowcolor{cyan}
Force Field Damping: 1.00 & 0.329232644023  & 0.329232644023  & 0.329232644023 \\ \hline
\rowcolor{cyan}
Force Field Distance: 20.00 & 0.329232644023  & 0.329232644023  & 0.329232644023 \\ \hline
\rowcolor{cyan}
Force Field Align to Normal: True & 0.329232644023  & 0.329232644023  & 0.329232644023 \\ \hline
Physics Type: Dynamic & 3.55513601614  & 18.1217630973  & 3.275450812 \\ \hline
\rowcolor{cyan}
Actor: False & 0.329232644023  & 0.329232644023  & 0.329232644023 \\ \hline
Ghost: True & 138.489494312  & 138.489494312  & 132.02387242 \\ \hline
\rowcolor{cyan}
Use Material Force Field: True & 0.329232644023  & 0.329232644023  & 0.329232644023 \\ \hline
\rowcolor{cyan}
Rotate From Normal: True & 0.329232644023  & 0.329232644023  & 0.329232644023 \\ \hline
\rowcolor{cyan}
No Sleeping: True & 0.329232644023  & 0.329232644023  & 0.329232644023 \\ \hline
\rowcolor{cyan}
Attributes Radius: 1cm & 0.329232644023  & 0.329232644023  & 0.329232644023 \\ \hline
Attributes Mass: 10000.0 & 3.57800913743  & 3.30042073543  & 3.21534852885 \\ \hline
Attributes Form Factor: 0.0 & 3.55513601614  & 18.1217630973  & 3.275450812 \\ \hline
\rowcolor{cyan}
Velocity Minimum: 1.0 & 0.329232644023  & 0.329232644023  & 0.329232644023 \\ \hline
\rowcolor{cyan}
Anisotropic Friction: True & 0.329232644023  & 0.329232644023  & 0.329232644023 \\ \hline
Velocity Maximum: 1.0 & 17.1034960114  & 17.130808295  & 16.8922077042 \\ \hline
Damping Translation: 1.0 & 17.9729741832 & 17.9729741832 & 17.9729741832 \\ \hline
Damping Rotation: 1.0 & 8.09457671285 & 5.47840838373 & 5.18331655137 \\ \hline
Collision Bounds: False & 8.81773036062 & 17.4044978663 & 2.80531111777 \\ \hline
Collision Bounds Margin: 0m & 18.740072391  & 9.79629223411  & 3.78119352088 \\ \hline
Collision Bounds: False & 4.28865271192  & 4.23797419961  & 3.72440427516 \\ \hline
Launch Dynamic Object Settings Force X: 30.0 & 5.21169989737  & 5.21169989737  & 3.78308993247 \\ \hline
Launch Dynamic Object Settings Torque X: 30.0 & 8.82943537929  & 8.70403741077  & 6.58255281735 \\ \hline
Launch Dynamic Object Settings AngV X: 30.0 & 2.93219084728  & 2.63246279507  & 1.82341393368 \\ \hline
Launch Dynamic Object Settings LinV X: 0.0 & 19.1625050915  & 19.1625050915  & 17.0670582483 \\ \hline
\rowcolor{cyan}
Launch Damping Frames: -32768 & 0.329232644023 & 0.329232644023  & 0.329232644023 \\ \hline
Collision Dynamic Object Settings Force X: 30.0 & 5.32618850819  & 18.9696056987  & 3.80913153981 \\ \hline
Collision Dynamic Object Settings Torque X: 30.0 & 1.67496526126  & 1.52842619107  & 1.52842619107 \\ \hline
Collision Dynamic Object Settings LinV X: 0.0 & 19.2801183238  & 19.1535557726  & 3.3918725084 \\ \hline
Collision Dynamic Object Settings AngV X: 30.0 & 4.69097055763 & 18.7403224372 & 3.80913153981 \\ \hline
\rowcolor{cyan}
Collision Damping Frames: -32768 & 0.329232644023 & 0.329232644023 & 0.329232644023 \\ \hline
\end{tabular}
\caption[Physics Engine Parameter Influences]{Here you see the distances between each tweaked-parameter ball path and the standard ball path per the three algorithms utilized. The highlighted tweaked parameters were determined not influential.}
\label{tab:distances}
\end{table}

\subsection[Experiment Two]{Experiment two: tournament selection with self-adaptation.}

Stub.
